0) Summary

Multiplayer web app. Admins create Games that contain multiple Sessions. In each Session, players vote Yes/No on one question and guess the total number of Yes votes. After the timer, reveal results and award points. Leaderboard is at the Game level (cumulative across Sessions).

Anti-cheat: During a live Session, no interim tallies (for anyone, including Admins). Results are revealed only after close.

1) Tech Stack & Project Setup

Frontend: React + Vite

Backend: Node.js + Express + Socket.IO

DB: SQLite (Prisma or better-sqlite3)

Auth:

Admin: simple cookie session (in-memory or SQLite table)

Participant: participantId in localStorage scoped to Game

Hosting: Single Replit project (web server + websockets)

Replit tasks

npm create vite@latest yes-game -- --template react

npm i express socket.io cors

npm i prisma @prisma/client (or better-sqlite3)

npm i cookie-session uuid zod

Dev scripts:

"dev": "concurrently \"vite\" \"node server.js\"" (install concurrently)

Or run server on a different port and proxy via Vite.

2) Domain Model (DB Schema)

Game

id (string/uuid), name, code (short join code)

status enum: active | archived

createdAt

Session

id, gameId, question (text), timerSeconds (int)

status enum: draft | live | closed | canceled

startedAt (datetime), endsAt (datetime|null), endedAt (datetime|null)

Participant

id, gameId, displayName, ownerAdminUserId? (nullable)
(Admin who owns this participant profile, if any)

createdAt

Submission (Vote + Guess in one row; last write wins before lock)

id, sessionId, participantId

vote enum: YES | NO | NULL (null until submitted)

guessYesCount (int|null)

submittedAt (datetime)

AdminUser

id, name, email?, createdAt

AuditLog (optional but recommended)

id, who (adminUserId), what, sessionId?, gameId?, at

Indexes

Submission(sessionId, participantId) unique

Session(gameId); Participant(gameId)

3) Core Rules
Scoring per Session

Let A = actualYesCount (count only submitted votes; non-voters excluded).

For each participant:

If guess == A → 5 pts

If abs(guess − A) == 1 → 3 pts

Else → 0 pts

If no guess → 0 pts

If no vote → excluded from totals and cannot earn points

Multiple participants can score (ties allowed).

Leaderboard (per Game)

Sum a participant’s points across all closed Sessions in the Game.

Timing / Joining

Admin sets timerSeconds (e.g., 30s)

Join cutoff: joining a live Session allowed until 10s remain

Participants may update vote/guess until expiry; server locks on expiry

Restart: allowed only if no submissions exist; otherwise clone a fresh Session

Anti-cheat

During live, no interim aggregates/tallies are emitted or returned via APIs (even to Admins).

Only on closed do we compute and emit results.

4) Routes & Two-Tab Workflow

Admin app: /admin/*

/admin/games/:gameId

Features: Create Session, Start Session, Restart (pre-submission only), Share Join link/code, Play as Participant (opens player route in new tab)

Live banner: “Session live — config locked; restart disabled after first submission”

No interim tallies during live

Player app: /play/:gameCode (or /game/:gameId/play)

Name input (persist to localStorage), join, vote, guess, see countdown, results after close

Typical Admin flow using two windows

Open /admin/games/:gameId, create Session, Start

Click Play as Participant → opens /play/:gameCode in new tab

Play normally in the player tab; admin tab shows timer & status only

At expiry, results appear in player tab; admin tab offers Show Results once closed

5) API (minimal)
REST

POST /api/games → { gameId, code }

GET /api/games/:gameId → { id, name, code, status, leaderboard[] }

POST /api/games/:gameId/sessions → { sessionId }

POST /api/sessions/:sessionId/start → { startedAt, endsAt }

POST /api/sessions/:sessionId/restart → clone settings to a new draft session; only allowed if no submissions yet

GET /api/sessions/:sessionId

When draft: full config

When live: minimal state only → { status, question, endsAt }

When closed: full results (see below)

WebSockets (Socket.IO)

Namespace: /session

Rooms: session:<sessionId>

session:join → payload { sessionId, participantId?, displayName }

Server returns { status, question, endsAt, yourSubmission? } (no aggregates)

session:submit → { vote?, guess? } (either or both)

Ack with yourSubmission (server saves; last write before lock wins)

session:tick → { now, endsAt } (1s cadence)

session:results (on close) →

{
  yesCount, noCount,
  rows: [
    { name, vote, guess, points },
    ...
  ],
  leaderboardDelta: [{ participantId, deltaPoints }]
}


Server must never emit counts during live.

6) Results Computation (transactional pseudocode)
// On timer expiry (server-side):
db.transaction(() => {
  // 1) Lock session
  update Session set status='closed', endedAt=now() where id=:sessionId;

  // 2) Fetch submissions that have a vote
  const subs = select * from Submission where sessionId=:sessionId;

  // 3) Compute A = number of YES votes among submitted votes
  const A = subs.filter(s => s.vote === 'YES').length;

  // 4) Score everyone
  const scored = subs.map(s => {
    const hasGuess = Number.isInteger(s.guessYesCount);
    if (!hasGuess) return { ...s, points: 0 };
    const err = Math.abs(s.guessYesCount - A);
    const points = err === 0 ? 5 : (err === 1 ? 3 : 0);
    return { ...s, points };
  });

  // 5) Persist points & update Game leaderboard totals
  insert into Points(sessionId, participantId, points) values ...
  // or write back to Submission + aggregate into GameParticipantTotals

  // 6) Build results payload
  emit 'session:results' to room with { yesCount, noCount, rows, leaderboardDelta }
});

7) UI Contract (maps to the wireframes)
Admin Console

Cards:

Game Settings + Share Join Code/Link

Create Session (Question, Timer)

Start / Restart (Restart hidden/disabled after first submission)

Session List (Draft / Live / Closed)

Play as Participant button (+ “Switch Admin ↔ Player” link)

While live: show Live-lock banner and disable controls

After closed: “Show Results” button (navigates to player-like results view)

Player — Live Session

Heading: “You are playing as: <name>”

Question, Big Timer, Yes/No buttons, Numeric Guess input

Submit/Update button (enabled until expiry)

If joining with ≤10s left, allow play if before cutoff; else show “Joining closed”

Player — Results

“Yes = N / No = M”

Winner(s)/close guessers highlighted

Table: Name | Vote | Guess | Points

Link/panel to Leaderboard (Game totals)

Game Lobby (Player)

Enter/display name, join Game by code, list of Sessions (Upcoming / Live / Closed)

8) Edge Cases & Resilience

Admin disconnects: Session continues; server is authoritative

Participant reloads: On re-join, server returns current state + last submission

Clock drift: Clients render from server endsAt; server rejects late writes

Double-submissions: Last write before lock wins

No participants: Still close cleanly; zero tallies

Privacy: Votes are public after close; nothing revealed during live

9) Acceptance Criteria (checklist)

Create Game; share join link/code

Create Session; Start -> Live -> auto Close at timer

Join cutoff at T ≤ 10s

Players can update vote/guess until expiry

No interim tallies shown anywhere during live (Admin or Player)

On close: totals + per-participant votes/guesses/points shown; multiple scorers allowed

Leaderboard updates after each closed Session (cumulative)

Admin can Play as Participant in a separate tab; both tabs work concurrently

Restart allowed only if no submissions exist; otherwise clone a new Session

Refresh/disconnect behavior restores correct state

10) Nice-to-Have (post-v1)

Anonymous mode (revealVotes=false)

Multi-Session run tool (schedule Sessions)

CSV export of results

Basic a11y pass (focus states, ARIA, contrast)

11) Hand-off Notes for Replit

Make sure websockets are enabled on the repl

Expose a single port; Vite dev server proxies /api and /socket.io/* to Node

Add a .replit run command if needed:

run = ["sh", "-c", "npm run dev"]
